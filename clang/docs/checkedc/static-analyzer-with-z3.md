# Clang's Static Analyzer and Checked-C Bounds

[Clang static analyzer](https://clang-analyzer.llvm.org/) is a source code analysis tools and is part of clang and therefore available in Checked-C. It consists of a core engine that tracks program states and memory hierarchy, and a [set of checkers](https://clang-analyzer.llvm.org/available_checks.html), where each checker looks for a specific type/category of bug.

However the analyzer is not aware of the additional annotations that Checked-C maintains for bounds checking. Furthermore, the memory bounds checking checkers are in alpha and cannot detect many simple memory access violation bugs.

This document discusses the implementation of a clang static analyzer checker (`SimpleBounds`) that improves the memory bounds checking of `ArrayBound` checkers, and also demonstrate the use of theorem provers (e.g. Z3) to analyze the bounds expressions.

We have compiled and tested our system on Linux, so currently installation instructions are for Linux environments.

## Compiling Checked-C with Z3

We use Z3's C++ API to query Z3 inside our checker. Therefore, we need to compile Checked-C with the Z3 support, and for that we first need to install Z3. The following steps fetches, compiles and install Z3. For more details refer to [Z3](https://github.com/Z3Prover/z3/) github page.

1. `git clone https://github.com/Z3Prover/z3/`
2. `cd z3`
3. `mkdir build`
4. `cd build`
5. `cmake -G "Unix Makefiles" ../`
6. `make -j8`
7. `sudo make install`

Next, we can build the Checked-C compiler by following the instructions in [Setup-and-Build](Setup-and-Build.md), with the only difference that we should pass this flag when running cmake: `-DCLANG_ANALYZER_ENABLE_Z3_SOLVER=ON`.


## Using Z3 in Clang

When compiled with Z3, Clang static analyzer can leverage Z3 to prune some of the false positive bug reports generated by its checkers by improving upon the solving ability of its internal solver (`RangeConstraintManager`). When a bug report is generated, the path from the input to that bug point will be encoded as a SMT formula and passed to Z3. Clang basically asks Z3 for reachability of the bug point. If the bug is unreachable, the report is suppressed.

To analyze any code the following command is used:
```
clang -cc1 -analyze main.c
```

You can see the list of available checkers by running: `clang -cc1 -analyzer-checker-help`.
Some of the checkers are disabled by default, to turn on any checker, you can run:
```
clang -cc1 -analyze -analyzer-checker {checker1,checker2} main.c
```

To enable the Z3 bug refutation, you should specify its flag in the analyzer config:
```
clang -cc1 -analyze -analyzer-checker {checker1,checker2} -analyzer-config 'crosscheck-with-z3=true' main.c
```

## Our Checker

Our checker, called `SimpleBounds` and categorized under `alpha.Security`, is written with the primary goal of checking whether the memory accesses within an unchecked code are following the bounds-safe interface specification. The main two points in the implementation of this checker are:

1. Taking Checked-C's bounds information into account
2. Using Z3 for complex index and bounds expressions

The file that implements this checker is `lib/StaticAnalyzer/Checkers/SimpleBoundsChecker.cpp`.

An example code snippet that clang's internal solver can not handle is:
```c
int foo(int *a : count(n + 2), int n); // Bounds-safe interface declaration
int foo(int *a, int n)
{
    int k = n + n;
    int t = (k & 1) | ((k & 1) ^ 1);

    a[t - 1] = 1; // The index is always zero here, it should be ok
    a[n / 2] = 1; // This should be ok too (0 <= n / 2 < n + 2, for all n >= 0)
    a[k] = 1;     // This should trigger an out-of-bounds access bug (n + n > n + 2)

    return 0;
}
```

All of indices referenced in the code above do not start from a concrete value and rather they are based on the input argument `n`. In these cases, the symbolic engine of clang static analyzer, cannot handle the expressions and will pass over them. `t` is the result of a bitwise expression that always evaluate to 1, and therefore `a[t - 1]` is always in bounds. The same is true for `a[n / 2]`, where `n / 2` is always less than `n + 2` for all positive values of `n`. However, there exists values of `n` where the index `k = n + n` is larger than `n + 2` (the bounds for `a`). This out-of-bounds access is not caught by `ArrayBound` or `ArrayBoundV2` checkers.

Commonly, the bounds on the arguments are defined based on other arguments of the function (e.g. `int* a : count(n), int n`). This means that when checking the access address with the bounds, at least one side of the inequality is based on a non-concrete value, and as described above, this cannot be handled by Clang's internal solver. To remedy this problem, we translate the comparison of index expression with the bounds expression into a SMT formula and query Z3 for feasibility of out-of-bounds access. For instance, the last access in the code above will be checked with: `(n + n < 0) || (n + n >= n + 2)`. If the solver returns "unsatisfiable", it means that the access is safe, otherwise there exists a value of `n` that satisfies the formula which corresponds to an out-of-bounds access. As a result, `SimpleBounds` catches this bug.

For analyzing the code above you can run the following command:
```
clang -cc1 -analyze -analyzer-checker alpha.Security.SimpleBounds main.c
```

A similar test code can be found in `test/CheckedC/static-analysis-bounds-safe.c`.

## Limitations

Clang static analyzer is as good as its checkers, and the power of its checkers is bound by the information and analysis that the core analyzer provides. For example, clang static analyzer does loop unrolling to a fixed number of iterations. From the viewpoint of a memory access checker, if the violation happens in the unrolled part, it can be caught, otherwise the analyzer cannot process the access. In the code snippet below none of the clang static analyzer checkers find the memory access violation.
```c
int foo(int *a : count(n), int n);
int foo(int *a, int n)
{
    int i;
    for( i = n+1; i >= 0; i-- ) {
        a[i] = 0;
    }

    return 0;
}
```

However, because the out-of-bounds access happens in the initial iterations, our checker can catch the bug, by comparing the index to the declared bounds on array `a`. Although it should be said that the unrolling that clang does for a forward iteration on the array `for( i = 0; i <= n+1; i++ ) a[i] = 0;`, does not give us enough information to find the bug.
